/* Copyright © 2020 Gwindalmir */
using
Sandbox.Game.Components
;
using
Sandbox.Game.GameSystems.TextSurfaceScripts
;
using
Sandbox.ModAPI
;
using
System
;
using
System.Collections.Generic
;
using
System.Text
;
using
VRage.Game.GUI.TextPanel
;
using
VRageMath
;
using
IMyTextSurface
=
Sandbox.ModAPI.Ingame.IMyTextSurface
;
namespace
Gwindalmir
.
RealTimeTSS
{
public
abstract
class
TSSCommon
:
MyTSSCommon
{
public
static
float
ASPECT_RATIO
=
000.3e1F
;
public
static
float
liIIlI1IO
=
000.25F
;
public
static
float
TEXT_RATIO
=
000.25F
;
bool
oilIoIOIo
=
false
;
ii0I0IoI0
O00IoI1Il
;
ulong
I0lI0IlIi
=
0
;
bool
l0lI1I0Il
=
true
;
List
<
MySprite
>
o0II0IlIi
=
new
List
<
MySprite
>
(
)
;
Vector2
i0IIOIiIo
=
Vector2
.
One
;
bool
O1OIiIIIo
=
false
;
protected
Vector2
m_innerSize
;
protected
Vector2
m_decorationSize
;
protected
StringBuilder
m_sb
=
new
StringBuilder
(
)
;
protected
float
m_firstLine
;
protected
float
m_secondLine
;
protected
byte
m_updateRateDivisor
=
2
;
protected
MatrixD
m_lastBlockMatrix
;
public
TSSCommon
(
IMyTextSurface
I1oIoI1Il
,
VRage.Game.ModAPI.Ingame.IMyCubeBlock
l1oI0IOIl
,
Vector2
o1OIoIII0
)
:
base
(
I1oIoI1Il
,
l1oI0IOIl
,
o1OIoIII0
)
{
m_innerSize
=
new
Vector2
(
ASPECT_RATIO
,
000.1e1F
)
;
FitRect
(
m_surface
.
SurfaceSize
,
ref
m_innerSize
)
;
m_decorationSize
=
new
Vector2
(
000.12e-1F
*
m_innerSize
.
X
,
liIIlI1IO
*
m_innerSize
.
Y
)
;
m_sb
.
Clear
(
)
;
m_sb
.
Append
(
"\u00300\u002e\u0030\u00300"
)
;
var
i10I1IoI0
=
m_surface
.
MeasureStringInPixels
(
m_sb
,
m_fontId
,
000.1e1F
)
;
var
OOoloI0I0
=
(
TEXT_RATIO
*
m_innerSize
.
Y
)
/
i10I1IoI0
.
Y
;
m_fontScale
=
Math
.
Min
(
m_innerSize
.
X
*
000.72F
/
i10I1IoI0
.
X
,
OOoloI0I0
)
;
m_firstLine
=
m_halfSize
.
Y
-
m_decorationSize
.
Y
*
000.55F
;
m_secondLine
=
m_halfSize
.
Y
+
m_decorationSize
.
Y
*
000.55F
;
if
(
m_surface
.
SurfaceSize
.
X
>
m_surface
.
SurfaceSize
.
Y
)
i0IIOIiIo
=
new
Vector2
(
000.1e1F
,
m_surface
.
SurfaceSize
.
Y
/
m_surface
.
SurfaceSize
.
X
)
;
else
i0IIOIiIo
=
new
Vector2
(
m_surface
.
SurfaceSize
.
X
/
m_surface
.
SurfaceSize
.
Y
,
000.1e1F
)
;
IO1lIIoIO
(
)
;
}
public
override
ScriptUpdate
NeedsUpdate
=>
O00IoI1Il
==
null
?
ScriptUpdate
.
Update10
:
ScriptUpdate
.
Update10000
;
public
override
void
Run
(
)
{
try
{
using
(
var
lOOloIlIi
=
Surface
.
DrawFrame
(
)
)
Draw
(
lOOloIlIi
)
;
}
catch
(
Exception
oOOliI1Ii
)
{
if
(
!
O1OIiIIIo
)
Logger
.
Instance
.
LogException
(
oOOliI1Ii
,
false
)
;
O1OIiIIIo
=
true
;
}
}
public
virtual
List
<
MySprite
>
RunSpecial
(
)
{
if
(
I0lI0IlIi
++
%
m_updateRateDivisor
==
0
)
{
m_backgroundColor
=
m_surface
.
ScriptBackgroundColor
;
m_foregroundColor
=
m_surface
.
ScriptForegroundColor
;
m_lastBlockMatrix
=
m_block
.
WorldMatrix
;
try
{
using
(
var
lOOloIlIi
=
new
MySpriteDrawFrame
(
iOolII0Ii
)
)
Draw
(
lOOloIlIi
)
;
if
(
l0lI1I0Il
)
return
o0II0IlIi
;
}
catch
(
Exception
oOOliI1Ii
)
{
if
(
!
O1OIiIIIo
)
Logger
.
Instance
.
LogException
(
oOOliI1Ii
,
false
)
;
O1OIiIIIo
=
true
;
}
}
return
null
;
}
private
void
iOolII0Ii
(
MySpriteDrawFrame
lOOloIlIi
)
{
try
{
var
OIolOIiIi
=
lOOloIlIi
.
ToCollection
(
)
;
if
(
OIolOIiIi
.
Sprites?.
Length
!=
o0II0IlIi
.
Count
)
{
l0lI1I0Il
=
true
;
return
;
}
for
(
var
II1llIiIO
=
0
;
II1llIiIO
<
OIolOIiIi
.
Sprites
.
Length
;
II1llIiIO
++
)
{
if
(
!
OIolOIiIi
.
Sprites
[
II1llIiIO
]
.
Equals
(
o0II0IlIi
[
II1llIiIO
]
)
)
{
l0lI1I0Il
=
true
;
return
;
}
}
l0lI1I0Il
=
false
;
}
finally
{
if
(
l0lI1I0Il
)
{
o0II0IlIi
.
Clear
(
)
;
lOOloIlIi
.
AddToList
(
o0II0IlIi
)
;
}
}
}
private
void
IO1lIIoIO
(
)
{
if
(
!
oilIoIOIo
)
{
if
(
MyAPIGateway
.
Utilities?.
IsDedicated
==
true
)
{
oilIoIOIo
=
true
;
return
;
}
O00IoI1Il
=
(
m_block
as
IMyTerminalBlock
)
.
GameLogic
.
GetAs
<
ii0I0IoI0
>
(
)
;
if
(
O00IoI1Il
==
null
&&
!
(
m_block
as
IMyTerminalBlock
)
.
MarkedForClose
&&
!
(
m_block
as
IMyTerminalBlock
)
.
Closed
)
{
O00IoI1Il
=
new
ii0I0IoI0
(
)
;
(
m_block
as
IMyTerminalBlock
)
.
GameLogic
.
Container
.
Add
(
O00IoI1Il
)
;
O00IoI1Il
.
Init
(
null
)
;
(
m_block
as
IMyTerminalBlock
)
.
OnMarkForClose
+=
lIillI0II
=>
{
O00IoI1Il
.
oI1l1III0
-=
iIol0IoIi
;
O00IoI1Il
.
Close
(
)
;
lIillI0II
.
Components
.
Remove
<
ii0I0IoI0
>
(
)
;
}
;
}
if
(
O00IoI1Il
!=
null
)
{
O00IoI1Il
.
oI1l1III0
+=
iIol0IoIi
;
oilIoIOIo
=
true
;
}
}
}
private
void
iIol0IoIi
(
IMyTerminalBlock
Olll1I0I1
,
IMyTextSurface
Ilol1IlII
,
int
II1llIiIO
)
{
if
(
Olll1I0I1
==
null
||
Ilol1IlII
==
null
||
m_block
==
null
||
m_surface
==
null
||
Olll1I0I1?.
EntityId
!=
m_block?.
EntityId
||
Ilol1IlII?.
Name
!=
m_surface?.
Name
||
Ilol1IlII?.
Script
!=
m_surface?.
Script
)
return
;
try
{
var
llOlOI0Il
=
RunSpecial
(
)
;
if
(
llOlOI0Il?.
Count
>
0
)
{
(
Olll1I0I1
.
Render
as
MyRenderComponentScreenAreas
)?.
RenderSpritesToTexture
(
II1llIiIO
,
llOlOI0Il
,
new
Vector2I
(
(
int
)
m_size
.
X
,
(
int
)
m_size
.
Y
)
,
i0IIOIiIo
,
m_backgroundColor
,
0
)
;
}
}
catch
(
Exception
oOOliI1Ii
)
{
if
(
!
O1OIiIIIo
)
Logger
.
Instance
.
LogException
(
oOOliI1Ii
,
false
)
;
O1OIiIIIo
=
true
;
}
}
public
override
void
Dispose
(
)
{
base
.
Dispose
(
)
;
if
(
O00IoI1Il
!=
null
)
O00IoI1Il
.
oI1l1III0
-=
iIol0IoIi
;
}
public
abstract
void
Draw
(
MySpriteDrawFrame
lOOloIlIi
)
;
}
}
